<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Debate BrazArg</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;700&family=Manrope:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">
  
<link rel="stylesheet" href="../src/styles/game.css">

<link rel="stylesheet" href="../src/styles/responsivegame.css">
</head>
<body>
  <!-- Fondo animado -->
  <div class="animated-bg"></div>
  
  <div class="floating-elements">
    <div class="floating-dot"></div>
    <div class="floating-dot"></div>
    <div class="floating-dot"></div>
    <div class="floating-dot"></div>
    <div class="floating-dot"></div>
  </div>

  <!-- NAV -->
  <nav class="navbar">
    <div class="nav-container">
      <a href="#" class="logo">
        <span>Debate BrazArg</span>
      </a>

      <ul class="nav-menu">
        <li><a class="nav-link" href="#" id="btnHelp" data-key="help_button">Ayuda</a></li>
        <li><a class="nav-link" href="#" id="btnRestart" data-key="restart_button">Reiniciar</a></li>
        <li><a class="nav-link" href="./portal.html" id="btnExit" data-key="exit_button">Salir</a></li>

        <!-- üåé Bot√≥n cambio de idioma -->
        <li>
          <button id="langToggle" class="nav-lang">
            <span id="langLabel">üá¶üá∑ ARG</span>
          </button>
        </li>

        <!-- üéµ Panel de m√∫sica -->
        <div class="music-panel-inline">
          <button id="btnPlayMusic">‚èØÔ∏è</button>
          <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="0.45">
        </div>
      </ul>
    </div>
  </nav>


  <!-- CONTENIDO PRINCIPAL -->
  <div class="game-container">
    <!-- Campo de batalla -->
  <section class="battlefield">
  <div class="battlefield-header-inline">
    <h2 class="section-title">Debate BrazArg</h2>
    <div id="eventDisplay" class="event-display-inline">
      <img id="eventIcon" src="../src/img/eventos/none.png" alt="Evento" class="event-icon-inline">
      <div class="event-info-inline">
        <div class="event-name-inline" id="eventName">Sin evento</div>
        <div class="event-desc-inline" id="eventDesc">‚Äî</div>
      </div>
    </div>
  </div>


<div class="battle-grid" id="grid">
  <div class="cell" id="p1"></div>
  <div class="cell" id="p2"></div>
  <div class="cell" id="p3"></div>
  <div class="cell" id="p4"></div>
  <div class="cell" id="p5"></div>
  <div class="cell" id="p6"></div>
  <div class="cell" id="p7"></div>
  <div class="cell" id="p8"></div>
  <div class="cell" id="player"></div>
</div>


</section>

    <!-- HUD lateral -->
    <aside class="side-hud">
  <div class="hud-block">
    <p class="small">
      <span data-key="round_label">Ronda N¬∞</span> <b id="round">1</b>
    </p>
    <p class="small">
      <span data-key="turn_label">Turno actual:</span> <b id="turnName">‚Äî</b>
    </p>
    <div class="timerbar mt-1"><div id="timerFill"></div></div>
    <p class="small mt-1">
      <span data-key="time_label">Tiempo restante:</span> <b id="timeLeft">20s</b>
    </p>
  </div>

  <div class="hud-block">
    <h3><span>‚≠ê</span> <span data-key="score_label">Puntaje:</span></h3>
    <p><span data-key="score_current">Actual:</span> <b id="score">0</b></p>
    <p class="muted small">
      <span data-key="score_best">M√°ximo:</span> <b id="best">0</b>
    </p>
  </div>

  <div class="hud-block">
    <div class="log" id="log"></div>
  </div>
</aside>

  </div>

  <!-- PlayerHUD -->
  <div class="player-hud">
    <div class="action-group">
      <button class="btn-ghost btn-danger" id="btnAttack">‚öîÔ∏è Atacar</button>
      <button class="btn-ghost btn-good" id="btnFortify">üõ°Ô∏è Fortificar</button>
      <button class="btn-ghost" id="btnRepair">‚ù§Ô∏è Curar</button>
      <div class="targets" id="targetBox"></div>
    </div>
    <div>
      <span class="hearts-lg" id="playerHearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
    </div>
  </div>

  <!-- Modal preguntas -->
  <div class="modal" id="qModal">
    <div class="modal-card">
      <div class="q-topic" id="qTopic">Tema</div>
      <div class="q-title" id="qTitle">Pregunta</div>
      <div class="options" id="qOptions"></div>
      <div class="explain" id="qExplain"></div>
      <div class="chips">
<div class="mt-2" style="text-align:right;">
  <button id="btnToggleLang" class="btn-ghost small">üåê Cambiar idioma</button>
  <button id="btnCloseQuestion" class="btn-ghost small">‚ùå Cerrar</button>
</div>

        <span class="chip" id="chipBonus" style="display:none;">üéØ +15% bonus</span>
      </div>
    </div>
  </div>

  <!-- Overlay Inicio -->
  <div class="overlay-center active" id="startOverlay">
    <div class="start-card">
      <h2 class="section-title" data-key="game_title" style="margin-bottom:12px;">Debate BrazArg</h2>
      <p class="mb-2" data-key="intro_subtitle">¬°Sobrevive y gana a los rivales resolviendo preguntas!</p>

      <div class="infotext-box">
        <h4 data-key="how_to_play_title">¬øC√≥mo se juega?</h4>
        <p data-key="rule_time">1) Turnos de <b>20s</b>. Si no actu√°s, perd√©s el turno y <b>-1 vida</b>.</p>
        <p data-key="rule_actions">2) Acciones:</p>
        <ul>
          <li data-key="rule_attack"><b>Atacar</b>: Ataca a un rival y si aciertas le restar√°s <b>-2 vidas</b>. Si fall√°s, perder√°s <b>-1 vida</b>.</li>
          <li data-key="rule_fortify"><b>Fortificar</b>: Si aciertas, recuper√°s <b>+3 vidas</b>.</li>
          <li data-key="rule_heal"><b>Curar</b>: Autom√°ticamente gan√°s <b>+1 vida</b>.</li>
        </ul>
      </div>

      <div class="mt-2">
        <label class="small" data-key="player_name_label">Tu nombre:</label>
        <input id="playerNameInput" class="btn-ghost" style="padding:8px 12px;" placeholder="Jugador" data-key="player_name_placeholder" />
      </div>

      <div class="mt-2">
        <label class="small" data-key="mode_label">Modo de juego:</label>
        <div class="btn-ghost" style="display:flex; flex-direction:column; gap:6px; align-items:flex-start; padding:8px 12px;">
          <label for="modeNormal" data-key="mode_normal_label" style="display:flex; gap:6px; align-items:center; cursor:pointer;">
            <input type="radio" name="gameMode" id="modeNormal" value="normal">
            <span data-key="mode_normal">Normal (4 jugadores)</span>
          </label>
          <label for="modeFull" data-key="mode_full_label" style="display:flex; gap:6px; align-items:center; cursor:pointer;">
            <input type="radio" name="gameMode" id="modeFull" value="full" checked>
            <span data-key="mode_full">Casa llena (8 jugadores)</span>
          </label>
        </div>
      </div>

      <button class="btn btn-primary mt-2" id="btnStart" data-key="start_button">Comenzar</button>
    </div>
  </div>


  <!-- Overlay Game Over -->
  <div class="overlay-center" id="endOverlay">
    <div class="end-card">
      <h2 class="section-title" id="endTitle">Fin de la partida</h2>
      <p id="endStats" class="mb-2"></p>
      <button class="btn btn-primary" id="btnPlayAgain">Jugar de nuevo</button>
    </div>
  </div>
  <div id="back"></div>

    <script>
        // ============================================
    //
    // ============================================

    // Utilidades b√°sicas
    const $ = sel => document.querySelector(sel);
    const $$ = sel => document.querySelectorAll(sel);
    const logBox = $("#log");

    function addLog(text) {
    const p = document.createElement("p");
    p.innerHTML = text;
    logBox.prepend(p);
    // Auto-scroll y limitar historial
    while (logBox.children.length > 20) {
        logBox.removeChild(logBox.lastChild);
    }
    }

    function clamp(n, a, b) { 
    return Math.max(a, Math.min(b, n)); 
    }

    function hearts(n) { 
    return "‚ù§Ô∏è".repeat(Math.max(0, n)) + "ü§ç".repeat(Math.max(0, 6-n)); 
    }

    function rnd(arr) { 
    return arr[Math.floor(Math.random() * arr.length)]; 
    }

    // ============================================
    // BANCO DE PREGUNTAS
    // ============================================
 let QUESTIONS = [];

async function loadQuestions() {
  try {
    const res = await fetch("../src/json/preguntas.json"); // üîπ ajust√° la ruta seg√∫n tu estructura
    if (!res.ok) throw new Error("Error al cargar preguntas");
    QUESTIONS = await res.json();
    console.log("‚úÖ Preguntas cargadas:", QUESTIONS.length);
  } catch (err) {
    console.error("‚ùå No se pudieron cargar las preguntas:", err);
    alert("Error al cargar las preguntas. Ver consola.");
  }
}

// ============================================
// SISTEMA DE TRADUCCI√ìN DE MENSAJES
// ============================================
let GAME_MESSAGES = {};
let currentGameLang = "arg";

async function loadGameMessages() {
  try {
    const res = await fetch("../src/json/game_messages.json");
    if (!res.ok) throw new Error("Error al cargar mensajes del juego");
    GAME_MESSAGES = await res.json();
    console.log("‚úÖ Mensajes del juego cargados");
  } catch (err) {
    console.error("‚ùå No se pudieron cargar los mensajes:", err);
    // Fallback: usar mensajes en espa√±ol por defecto
    GAME_MESSAGES = { arg: {}, brz: {} };
  }
}

// Funci√≥n auxiliar para obtener mensaje traducido
function t(key, replacements = {}) {
  let msg = GAME_MESSAGES[currentGameLang]?.[key] || GAME_MESSAGES.arg?.[key] || key;
  
  // Reemplazar variables {name}, {target}, etc.
  Object.keys(replacements).forEach(k => {
    msg = msg.replace(new RegExp(`{${k}}`, 'g'), replacements[k]);
  });
  
  return msg;
}

// Sincronizar idioma de mensajes con idioma de UI
function syncGameLanguage(lang) {
  currentGameLang = lang;
}

    // ============================================
    // CONSTANTES Y ESTADO GLOBAL
    // ============================================
    const MAX_HP = 6;
    const INIT_HP = 5;
    const TURN_TIME = 20;

    let state = null;
    let gameEnded = false;

    const baseTips = [
    ""
    ];

    // ============================================
    // INICIALIZACI√ìN DEL JUEGO
    // ============================================
function randomizeGridPositions(mode) {
  const grid = document.getElementById("grid");
  grid.classList.remove("normal", "full");
  grid.classList.add(mode);

  // üßπ Limpiar n√∫cleo anterior si existe
  const oldCore = grid.querySelector(".center-core");
  if (oldCore) oldCore.remove();

  // üéØ Posiciones disponibles para modo normal (forma de cruz)
  const normalPositions = [
    { id: "p1", area: "1 / 2" }, // arriba
    { id: "p2", area: "2 / 1" }, // izquierda
    { id: "p3", area: "2 / 3" }, // derecha
    { id: "p4", area: "3 / 1" }, // abajo-izquierda (extra si hay 4 bots)
  ];

  // üîÄ Barajamos las posiciones solo para los NPCs
  const shuffledNormal = normalPositions.sort(() => Math.random() - 0.5);

  // üéØ Posiciones para modo full (ya conocidas)
  const fullPositions = [
    { id: "p1", area: "1 / 1" },
    { id: "p2", area: "1 / 2" },
    { id: "p3", area: "1 / 3" },
    { id: "p4", area: "2 / 1" },
    { id: "p5", area: "2 / 3" },
    { id: "p6", area: "3 / 1" },
    { id: "p7", area: "3 / 3" },
  ];

  const positions = mode === "full" ? fullPositions : shuffledNormal;

  // üßç‚Äç‚ôÇÔ∏è Aplicar a las celdas
  positions.forEach((slot, i) => {
    const el = document.getElementById(slot.id);
    if (el) el.style.gridArea = slot.area;
  });

  // üë§ Jugador fijo en la parte inferior central
  const player = document.getElementById("player");
  if (player) player.style.gridArea = "3 / 2";

  // ‚ö° Si es modo FULL, agregamos el n√∫cleo visual (vac√≠o)
  if (mode === "full") {
    const center = document.createElement("div");
    center.className = "cell center-core";
    center.style.gridArea = "2 / 2";
    center.innerHTML = "<div class='core-energy'></div>";
    grid.appendChild(center);
  }
}

function newGame(playerName = "Jugador", mode = "normal") {
  const best = Number(localStorage.getItem("bp_best") || 0);
  $("#best").textContent = best;
  gameEnded = false;

  const players = buildPlayers(playerName, mode);

  state = {
    round: 1,
    turnIdx: 0,
    score: 0,
    timer: TURN_TIME,
    interval: null,
    awaitingAnswer: false,
    chosenAction: null,
    chosenTarget: null,
    players,
    order: generarOrdenHorario(players.length),
  };

  // üßπ Reset de eventos activos
  state.currentEvent = null;
  state.eventMultiplier = 1;
  state.eventAccuracyPenalty = 0;
  state.eventExtraDamage = 0;

  // üîÑ Actualizar visualmente el √°rea de evento con traducci√≥n
  const suffix = currentGameLang === "brz" ? "_brz" : "_arg";
  $("#eventName").textContent = ROUND_EVENTS[3][`name${suffix}`]; // Silencio de la Bandera
  $("#eventDesc").textContent = ROUND_EVENTS[3][`desc${suffix}`];
  $("#eventIcon").src = "../src/img/event_5.jpg";
  $("#eventDisplay").style.boxShadow = "0 0 15px rgba(255,255,255,0.1)";

  randomizeGridPositions(mode);

  logBox.innerHTML = "";
  $("#score").textContent = state.score;
  $("#round").textContent = state.round;

  renderAll();
  highlightTurn();
  startTurnTimer();

  addLog(t("game_started"));
  if (music.paused) {
    music.play();
    $("#btnPlayMusic").textContent = "‚è∏Ô∏è";
  }
}
    // ============================================
    // RENDERIZADO
    // ============================================
    function renderAll() {

// Render din√°mico seg√∫n existan jugadores
for (let i = 0; i < state.players.length; i++) {
  renderCastle(idFromIndex(i), state.players[i]);
}




    ["#dummy1", "#dummy2", "#dummy3", "#dummy4"].forEach(sel => {
        const box = $(sel);
        if (box) box.innerHTML = "";
    });

    // Vidas del jugador en HUD inferior
    $("#playerHearts").textContent = hearts(state.players[0].hp);

    // Habilitar/deshabilitar controles seg√∫n turno
    const myTurn = state.order[state.turnIdx] === 0 && !state.awaitingAnswer;
    togglePlayerControls(myTurn);
    }

    // ============================================
// EVENTOS ESPECIALES CON IM√ÅGENES
// ============================================
const ROUND_EVENTS = [
  {
    name_arg: "Revoluci√≥n de Mayo",
    name_brz: "Revolu√ß√£o de Maio",
    desc_arg: "El esp√≠ritu patri√≥tico se enciende: todas las acciones exitosas otorgan el doble de puntos.",
    desc_brz: "O esp√≠rito patri√≥tico se acende: todas as a√ß√µes bem-sucedidas d√£o o dobro de pontos.",
    icon: "../src/img/event_3.jpg",
    effect: state => state.eventMultiplier = 2
  },
  {
    name_arg: "Renacer de la Patria",
    name_brz: "Renascimento da P√°tria",
    desc_arg: "Todos los h√©roes vivos recuperan +1 vida en nombre de la Naci√≥n.",
    desc_brz: "Todos os her√≥is vivos recuperam +1 vida em nome da Na√ß√£o.",
    icon: "../src/img/event_2.jpg",
    effect: state => {
      state.players.forEach((p, idx) => {
        if (!p.alive) return;

        if (p.hp < MAX_HP) {
          p.hp = clamp(p.hp + 1, 0, MAX_HP);
          showDamageFloat(idFromIndex(idx), 1, "heal");
          launchEffect(idFromIndex(idx), "heal");
          sfx.heal.play();
        } else {
          const bonus = 100;
          p.score = (p.score || 0) + bonus;
          if (idx === 0) {
            state.score += bonus;
            $("#score").textContent = state.score;
          }
          showPointsFloat(idFromIndex(idx), bonus);
          sfx.event_double.play();
        }
      });
      renderAll();
    }
  },
  {
    name_arg: "Fervor Nacional",
    name_brz: "Fervor Nacional",
    desc_arg: "La pasi√≥n argentina arde en el campo de batalla: el da√±o aumenta +1.",
    desc_brz: "A paix√£o argentina arde no campo de batalha: o dano aumenta +1.",
    icon: "../src/img/event_1.jpg",
    effect: state => state.eventExtraDamage = 1
  },
  {
    name_arg: "Silencio de la Bandera",
    name_brz: "Sil√™ncio da Bandeira",
    desc_arg: "Un instante de calma. No hay eventos activos este turno.",
    desc_brz: "Um instante de calma. N√£o h√° eventos ativos neste turno.",
    icon: "../src/img/event_5.jpg",
    effect: state => {
      state.eventMultiplier = 0;
      state.eventAccuracyPenalty = 0;
      state.eventExtraDamage = 0;
    }
  }
];
// ======================================================
// ORDEN DE TURNOS EN C√çRCULO ANTIHORARIO (TRUCO INVERTIDO üòé)
// ======================================================
function generarOrdenHorario(totalPlayers) {
  if (totalPlayers === 4) {
    // player (abajo) ‚Üí izquierda (p2) ‚Üí arriba (p1) ‚Üí derecha (p3)
    return [0, 3, 1, 2];
  }

  if (totalPlayers === 8) {
    // player ‚Üí p7 ‚Üí p5 ‚Üí p3 ‚Üí p2 ‚Üí p1 ‚Üí p4 ‚Üí p6
    return [0, 7, 5, 3, 2, 1, 4, 6];
  }

  return Array.from({ length: totalPlayers }, (_, i) => i);
}


function applyRoundEvent() {
  const event = rnd(ROUND_EVENTS);
  state.currentEvent = event; // üîπ Guardar evento para poder re-traducirlo
  
  const suffix = currentGameLang === "brz" ? "_brz" : "_arg";
  const name = event[`name${suffix}`];
  const desc = event[`desc${suffix}`];

  state.eventMultiplier = 1;
  state.eventAccuracyPenalty = 0;
  state.eventExtraDamage = 0;
  event.effect(state);

  $("#eventName").textContent = name;
  $("#eventDesc").textContent = desc;
  $("#eventIcon").src = event.icon;

  const eventBox = $("#eventDisplay");
  eventBox.classList.add("flashEvent");
  setTimeout(() => eventBox.classList.remove("flashEvent"), 800);

  eventBox.style.boxShadow =
    name.includes("Doble") || name.includes("Revoluci√≥n") || name.includes("Revolu√ß√£o") ? "0 0 15px rgba(255,215,0,0.4)" :
    name.includes("Curaci√≥n") || name.includes("Renacer") || name.includes("Renascimento") ? "0 0 15px rgba(0,255,153,0.4)" :
    name.includes("Furia") || name.includes("Fervor") ? "0 0 15px rgba(255,80,80,0.4)" :
    "0 0 15px rgba(255,255,255,0.1)";

  // Sonidos seg√∫n tipo de evento
  if (name.includes("Revoluci√≥n") || name.includes("Revolu√ß√£o")) {
    sfx.event_double.play();
  } else if (name.includes("Renacer") || name.includes("Renascimento")) {
    sfx.event_heal.play();
  } else if (name.includes("Fervor")) {
    sfx.event_fury.play();
  } else {
    sfx.event_none.play();
  }

  addLog(t("event_applied", { name, desc }));
}

    const SCORE_VALUES = {
  ATTACK_SUCCESS: 80,
  FORTIFY_SUCCESS: 80,
  KILL_BONUS: 200,
  REPAIR: 0,
  FAIL: 0
};

function renderCastle(sel, p) {
  const box = $(sel);
  if (!box) return;
  if (!p) return (box.innerHTML = "");

  // ‚ö∞Ô∏è Si est√° muerto
  if (!p.alive) {
    box.innerHTML = `
      <div class="castle-info">
        <div class="avatar dead"></div>
        <div class="name muted">${p.name}</div>
      </div>
      <div class="points">‚≠ê ${p.score || 0}</div>
      <div class="lifes">${t("deceased_symbol")}</div>
    `;
    return;
  }

  // üß± Personaje vivo
  const playerType = p.type === 'bot' ? t("Bot") : t("Player");
  
  box.innerHTML = `
    <div class="castle-info">
      <div class="avatar" style="background-image:url('${p.img || 'img/default.png'}');"></div>
    </div>

    <div class="name-block">
      <div class="name">${p.name}</div>
      <div class="role small muted">${playerType}</div>
      <div class="points">‚≠ê ${p.score || 0}</div>
    </div>

    <div class="lifes">${hearts(p.hp)}</div>
    ${p.type === "bot" && p.thinking ? `<div class="thinking">${p.thinking}</div>` : ""}
  `;
}
const THOUGHTS_ARG = [
  "{name} recuerda la Revoluci√≥n de Mayo‚Ä¶",
  "{name} planea una estrategia libertadora‚Ä¶",
  "{name} piensa en su pr√≥ximo discurso‚Ä¶",
  "{name} escucha el murmullo del pueblo‚Ä¶",
  "{name} consulta la Constituci√≥n‚Ä¶",
  "{name} analiza la situaci√≥n del pa√≠s‚Ä¶",
  "{name} evoca a los h√©roes patrios‚Ä¶",
  "{name} defiende la educaci√≥n p√∫blica‚Ä¶",
  "{name} busca inspiraci√≥n en el tango‚Ä¶",
  "{name} calcula la t√°ctica de San Lorenzo‚Ä¶",
  "{name} afina su guitarra criolla‚Ä¶",
  "{name} ondea la bandera celeste y blanca‚Ä¶",
  "{name} piensa c√≥mo unir al pueblo‚Ä¶",
  "{name} recuerda a los ca√≠dos por la patria‚Ä¶",
  "{name} prepara su pr√≥xima revoluci√≥n‚Ä¶",
    "{name} mira el horizonte y sue√±a con libertad‚Ä¶",
  "{name} traza un plan digno de un pr√≥cer‚Ä¶",
  "{name} piensa en el futuro de la patria‚Ä¶",
  "{name} escucha el eco de la historia‚Ä¶",
  "{name} recuerda las voces del pueblo‚Ä¶",
  "{name} levanta su copa por la independencia‚Ä¶",
  "{name} afila su pluma para escribir historia‚Ä¶",
  "{name} siente el peso del deber argentino‚Ä¶",
  "{name} respira hondo y sigue la causa‚Ä¶",
  "{name} honra la bandera con el alma‚Ä¶",
  "{name} recuerda a los que nunca se rindieron‚Ä¶",
  "{name} enciende el fuego de una nueva era‚Ä¶",
  "{name} escucha marchas en su memoria‚Ä¶",
  "{name} siente el pulso de la revoluci√≥n‚Ä¶",
  "{name} defiende sus ideales con pasi√≥n‚Ä¶",
  "{name} contempla el cielo celeste y blanco‚Ä¶",
  "{name} guarda silencio, pero planea acci√≥n‚Ä¶",
  "{name} sonr√≠e ante el destino de su naci√≥n‚Ä¶",
  "{name} jura no olvidar jam√°s la historia‚Ä¶"
];


const THOUGHTS_BRZ = [
  "{name} lembra a Revolu√ß√£o de Maio‚Ä¶",
  "{name} planeja uma estrat√©gia libertadora‚Ä¶",
  "{name} pensa em seu pr√≥ximo discurso‚Ä¶",
  "{name} ouve o murm√∫rio do povo‚Ä¶",
  "{name} consulta a Constitui√ß√£o‚Ä¶",
  "{name} analisa a situa√ß√£o do pa√≠s‚Ä¶",
  "{name} evoca os her√≥is p√°trios‚Ä¶",
  "{name} defende a educa√ß√£o p√∫blica‚Ä¶",
  "{name} busca inspira√ß√£o no tango‚Ä¶",
  "{name} calcula a t√°tica de San Lorenzo‚Ä¶",
  "{name} afina seu viol√£o crioulo‚Ä¶",
  "{name} agita a bandeira celeste e branca‚Ä¶",
  "{name} pensa como unir o povo‚Ä¶",
  "{name} lembra os ca√≠dos pela p√°tria‚Ä¶",
  "{name} prepara sua pr√≥xima revolu√ß√£o‚Ä¶",
  "{name} olha o horizonte e sonha com liberdade‚Ä¶",
  "{name} tra√ßa um plano digno de um pr√≥cer‚Ä¶",
  "{name} pensa no futuro da p√°tria‚Ä¶",
  "{name} escuta o eco da hist√≥ria‚Ä¶",
  "{name} lembra as vozes do povo‚Ä¶",
  "{name} levanta sua ta√ßa pela independ√™ncia‚Ä¶",
  "{name} afia sua pena para escrever hist√≥ria‚Ä¶",
  "{name} sente o peso do dever argentino‚Ä¶",
  "{name} respira fundo e segue a causa‚Ä¶",
  "{name} honra a bandeira com a alma‚Ä¶",
  "{name} lembra os que nunca se renderam‚Ä¶",
  "{name} acende o fogo de uma nova era‚Ä¶",
  "{name} escuta marchas em sua mem√≥ria‚Ä¶",
  "{name} sente o pulso da revolu√ß√£o‚Ä¶",
  "{name} defende seus ideais com paix√£o‚Ä¶",
  "{name} contempla o c√©u celeste e branco‚Ä¶",
  "{name} guarda sil√™ncio, mas planeja a√ß√£o‚Ä¶",
  "{name} sorri ante o destino de sua na√ß√£o‚Ä¶",
  "{name} jura n√£o esquecer jamais a hist√≥ria‚Ä¶"
];

function getThoughts() {
  return currentGameLang === "brz" ? THOUGHTS_BRZ : THOUGHTS_ARG;
}


// Muestra el mensaje debajo de las vidas por un rato
function botSay(idx, text, ms = 1200) {
  const p = state.players[idx];
  if (!p || !p.alive) return;
  p.thinking = text;
  renderAll();
  setTimeout(() => {
    // si sigue vivo, limpiamos el mensaje
    if (p.alive) {
      p.thinking = "";
      renderAll();
    }
  }, ms);
}


function buildPlayers(playerName, mode) {
  const allBots = [
    { id: "1", name: "Maradona",   type: "bot", hp: INIT_HP, acc: 0.75, alive: true, img: "../src/img/pj_8.jpg" },
    { id: "2", name: "Ronaldinho",     type: "bot", hp: INIT_HP, acc: 0.8,  alive: true, img: "../src/img/pj_3.jpg" },
    { id: "3", name: "Messi",        type: "bot", hp: INIT_HP, acc: 0.65, alive: true, img: "../src/img/pj_7.jpg" },
    { id: "4", name: "Neymar",        type: "bot", hp: INIT_HP, acc: 0.68, alive: true, img: "../src/img/pj_4.jpg" },
    { id: "5", name: "Di Maria",        type: "bot", hp: INIT_HP, acc: 0.72, alive: true, img: "../src/img/pj_5.jpg" },
    { id: "6", name: "Ronaldo",       type: "bot", hp: INIT_HP, acc: 0.7,  alive: true, img: "../src/img/pj_2.jpg" },
    { id: "7", name: "Dibu",     type: "bot", hp: INIT_HP, acc: 0.68, alive: true, img: "../src/img/pj_6.jpg" }, 
    ];
  const human = { id: "H", name: playerName, type: "human", hp: INIT_HP, acc: 0.75, alive: true, img: "../src/img/pj_1.jpg" };

  // üß† Barajamos todo el conjunto de bots
  const shuffled = allBots.sort(() => Math.random() - 0.5);

  // üéØ Selecci√≥n aleatoria seg√∫n modo
  const numBots = mode === "full" ? 7 : 3;
  const selectedBots = shuffled.slice(0, numBots);

  // üß© Devolvemos el jugador + bots seleccionados
  return [human, ...selectedBots];
}




// ============================================
// CONTROL VISUAL DE BOTONES DEL JUGADOR
// ============================================
function togglePlayerControls(enabled) {
  const actionGroup = document.querySelector(".player-hud .action-group");
  const targetBox = $("#targetBox");

  // üîπ Mostrar u ocultar el grupo completo
  if (enabled) {
    actionGroup.classList.remove("hidden");
  } else {
    actionGroup.classList.add("hidden");
  }

  // üîπ Limpiar objetivos
  targetBox.innerHTML = "";
  targetBox.classList.remove("active", "attack-mode");

  // üîπ Si es tu turno (enabled), generar los botones de objetivo
  if (enabled) {
    state.players.forEach((p, idx) => {
      if (idx > 0 && p.alive) {
        const btn = document.createElement("button");
        btn.className = "btn-ghost";
        btn.textContent = p.name;
        btn.onclick = () => selectTarget(idx);
        targetBox.appendChild(btn);
      }
    });
  }
}


function highlightTurn() {
const idx = state.order[state.turnIdx];
  const p = state.players[idx];

  $("#turnName").textContent = p ? p.name : t("empty_placeholder");

  // Limpiar resaltado
  $$(".cell").forEach(c => c.classList.remove("active-turn"));

  const idMap = { 
    0: "#player", 1: "#p1", 2: "#p2", 3: "#p3",
    4: "#p4", 5: "#p5", 6: "#p6", 7: "#p7", 8: "#p8"
  };

  const sel = idMap[idx];
  if (sel) {
    const cell = $(sel);
    if (cell) cell.classList.add("active-turn");
  }

  // Efecto en HUD inferior si es turno del jugador
  const playerHUD = document.querySelector(".player-hud");
  playerHUD.classList.toggle("active-turn", state.order[state.turnIdx] === 0);

  // üí≠ Si es turno de un bot vivo ‚Üí mostrar mensaje "pensando..."
// üí≠ Si es turno de un bot vivo ‚Üí mostrar mensaje solo desde la segunda ronda
if (p && p.type === "bot" && p.alive && state.round > 1) {
  const msg = rnd(getThoughts()).replace("{name}", p.name);
  p.thinking = msg;
  renderAll();

  setTimeout(() => {
    if (p.alive && state.players[state.order[state.turnIdx]] === p) {
      p.thinking = "";
      renderAll();
    }
  }, 1300);
}
}

    function current() {
    return state.players[state.order[state.turnIdx]];
    }

    // ============================================
    // TEMPORIZADOR DE TURNO
    // ============================================
function startTurnTimer() {
  clearInterval(state.interval);
  state.timer = TURN_TIME;
  state.awaitingAnswer = false; // ‚úÖ Reiniciamos flag cada nuevo turno

  // üîπ Elegir una pregunta fija al comenzar el turno del jugador
if (state.order[state.turnIdx] === 0) {
  state.fixedQuestion = rnd(QUESTIONS);
    state.remainingChanges = 3;
}


  updateTimerUI();

  state.interval = setInterval(() => {
    if (gameEnded || state.awaitingAnswer) return;

    state.timer -= 1;
    updateTimerUI();

    if (state.timer <= 0) {
      clearInterval(state.interval);
      onTimeOut();
    }
  }, 1000);
}

    function updateTimerUI() {
    $("#timeLeft").textContent = state.timer + "s";
    const pct = Math.max(0, (state.timer / TURN_TIME) * 100);
    const fill = $("#timerFill");
    fill.style.width = pct + "%";

    // Cambiar color seg√∫n tiempo restante
    if (state.timer > 10) {
        fill.style.background = "linear-gradient(90deg, #00d084, #9cffac)";
    } else if (state.timer > 5) {
        fill.style.background = "linear-gradient(90deg, #ffd166, #ffe29a)";
    } else {
        fill.style.background = "linear-gradient(90deg, #ff6b6b, #ffa3a3)";
    }
    }

    function onTimeOut() {
    if (gameEnded) return;
    
    const actorIdx = state.order[state.turnIdx];
    const actor = state.players[actorIdx];

    if (!actor || !actor.alive) {
        endTurn();
        return;
    }

    if (actor.type === "human") {
        actor.hp = clamp(actor.hp - 1, 0, MAX_HP);
        addLog(t("time_out_player"));
        checkDeath(actorIdx);
        renderAll();
    } else {
        addLog(t("time_out_bot", { name: actor.name }));
    }

    endTurn();
    }

    // ============================================
    // ACCIONES DEL JUGADOR
    // ============================================
    function isMyTurn() {
    return state.order[state.turnIdx] === 0 && !gameEnded;
    }

  $("#btnAttack").onclick = () => {
    if (!isMyTurn() || state.awaitingAnswer) return;
    state.chosenAction = "attack";
    const targetBox = $("#targetBox");
    targetBox.classList.add("active", "attack-mode"); // üî¥ activamos modo ataque visual
addLog(t("choose_target"));
  };


    function selectTarget(idx) {
    if (!isMyTurn() || state.awaitingAnswer) return;
    
    if (!state.players[idx] || !state.players[idx].alive) {
        addLog(t("invalid_target"));
        return;
    }
    
    state.chosenTarget = idx;
    
    if (state.chosenAction === "attack") {
        $("#targetBox").classList.remove("active");
        clearInterval(state.interval); // Pausar timer durante pregunta
        askQuestion("attack");
    }
    }

    $("#btnFortify").onclick = () => {
    if (!isMyTurn() || state.awaitingAnswer) return;
    state.chosenAction = "fortify";
    clearInterval(state.interval); // Pausar timer durante pregunta
    askQuestion("fortify");
    };

    $("#btnRepair").onclick = () => {
    if (!isMyTurn() || state.awaitingAnswer) return;
    const me = state.players[0];
    me.hp = clamp(me.hp + 1, 0, MAX_HP);
    showDamageFloat("#player", 1, "heal");

    addLog(t("heal_self", { name: me.name }));
    renderAll();
    endTurn();
    launchEffect("#player", "heal");
    sfx.heal.play();
    };



// ============================================
// üåé SISTEMA DE PREGUNTAS BILING√úE
// ============================================
// ============================================
// üåé SISTEMA DE PREGUNTAS BILING√úE
// ============================================

// Estado temporal
let savedTimer = null;
let currentLanguage = currentGameLang; // usa el idioma actual del juego

let currentQuestion = null;
let currentKind = null;
let currentShuffled = []; // orden mezclado fijo por pregunta

function askQuestion(kind) {
  savedTimer = state.timer;
  state.awaitingAnswer = true;
  currentKind = kind;

  $("#qModal").classList.add("active");
// üîπ Asegurar que el bot√≥n de idioma vuelva a mostrarse
const toggleLangBtn = document.getElementById("btnToggleLang");
if (toggleLangBtn) toggleLangBtn.style.display = "inline-block";

  // üîπ Elegir pregunta
  const q = state.order[state.turnIdx] === 0 && state.fixedQuestion
    ? state.fixedQuestion
    : rnd(QUESTIONS);
  currentQuestion = q;

  // üîπ Crear bot√≥n ‚ÄúCambiar pregunta (3)‚Äù si no existe
  let changeBtn = document.getElementById("changeQuestionBtn");
  if (!changeBtn) {
    changeBtn = document.createElement("button");
    changeBtn.id = "changeQuestionBtn";
    changeBtn.className = "btn-ghost small";
    changeBtn.style.marginRight = "8px";
    const closeBtn = document.getElementById("btnCloseQuestion");
    closeBtn.parentNode.insertBefore(changeBtn, closeBtn);
  }
  changeBtn.textContent = t("change_question_btn", { count: state.remainingChanges });
  changeBtn.onclick = () => changeQuestion(kind);
  changeBtn.style.display = "inline-block";
  changeBtn.disabled = state.remainingChanges <= 0;

  // üîπ Mezclamos opciones una sola vez y guardamos el orden
  const opts = q.options_arg || q.options || [];
  currentShuffled = opts.map((_, i) => i).sort(() => Math.random() - 0.5);

  // sincronizar el idioma de la pregunta con el del juego
currentLanguage = currentGameLang;
renderQuestion(q, currentLanguage);

}

// ============================================
// üîÅ CAMBIAR IDIOMA EN VIVO
// ============================================
$("#btnToggleLang").onclick = () => {
  if (!currentQuestion) return;
  currentLanguage = currentLanguage === "arg" ? "brz" : "arg";
  renderQuestion(currentQuestion, currentLanguage);
};

// ============================================
// üîπ FUNCI√ìN CENTRAL DE RENDERIZADO
// ============================================
function renderQuestion(q, lang = "arg") {
  const prefix = lang === "brz" ? "_brz" : "_arg";

  $("#qTopic").textContent = q[`topic${prefix}`] || "‚Äî";
  $("#qTitle").textContent = q[`q${prefix}`] || "‚Äî";
  $("#qExplain").style.display = "none";
  $("#qExplain").innerHTML = "";

  // ‚úÖ Imagen
  const imgBox = document.getElementById("qImage");
  if (q.img) {
    if (!imgBox) {
      const imgEl = document.createElement("img");
      imgEl.id = "qImage";
      imgEl.src = q.img;
      imgEl.style = `
        width: 100%;
        max-height: 140px;
        object-fit: cover;
        border-radius: 10px;
        margin-bottom: 10px;
        opacity: 0.95;
      `;
      $("#qTitle").insertAdjacentElement("beforebegin", imgEl);
    } else {
      imgBox.src = q.img;
      imgBox.style.display = "block";
    }
  } else if (imgBox) {
    imgBox.style.display = "none";
  }

  // ‚úÖ Opciones (mismo orden en ambos idiomas)
  const optBox = $("#qOptions");
  optBox.innerHTML = "";
  currentShuffled.forEach((originalIndex) => {
    const btn = document.createElement("button");
    btn.className = "opt";
    btn.textContent = q[`options${prefix}`][originalIndex];
    btn.onclick = () => resolveQuestion(q, originalIndex, currentKind);
    optBox.appendChild(btn);
  });

  // ‚úÖ Texto del bot√≥n idioma
  const oppositeLang = lang === "arg" ? "brz" : "arg";
$("#btnToggleLang").textContent =
  oppositeLang === "brz" ? "üáßüá∑ " : "üá¶üá∑ ";

}

// ============================================
// üîÅ CAMBIAR PREGUNTA (bot√≥n Cambiar)
// ============================================
function changeQuestion(kind) {
  if (state.remainingChanges > 0) {
    state.remainingChanges--;
    const newQ = rnd(QUESTIONS);
    state.fixedQuestion = newQ;
    currentQuestion = newQ;

    const opts = newQ.options_arg || newQ.options || [];
    currentShuffled = opts.map((_, i) => i).sort(() => Math.random() - 0.5);

    renderQuestion(newQ, currentLanguage);

    const btn = document.getElementById("changeQuestionBtn");
    if (btn) {
      btn.textContent = t("change_question_btn", { count: state.remainingChanges });
      if (state.remainingChanges <= 0) btn.disabled = true;
    }
  }
}
// ============================================
// üîí CERRAR PREGUNTA
// ============================================
$("#btnCloseQuestion").onclick = () => {
  $("#qModal").classList.remove("active");
  state.awaitingAnswer = false;
  state.chosenAction = null;
  state.chosenTarget = null;
  if (savedTimer && savedTimer > 0) state.timer = savedTimer;
  if (state.order[state.turnIdx] === 0 && !gameEnded) {
    clearInterval(state.interval);
    updateTimerUI();
    state.interval = setInterval(() => {
      if (gameEnded || state.awaitingAnswer) return;
      state.timer -= 1;
      updateTimerUI();
      if (state.timer <= 0) {
        clearInterval(state.interval);
        onTimeOut();
      }
    }, 1000);
    togglePlayerControls(true);
    addLog(t("question_closed"));
  }
};

// ============================================
// ‚úÖ EVALUAR RESPUESTA
// ============================================
function resolveQuestion(q, idx, kind) {
  if (!state.awaitingAnswer) return;
  state.awaitingAnswer = false;

  $("#btnCloseQuestion").style.display = "none";
const changeBtn = document.getElementById("changeQuestionBtn");
if (changeBtn) changeBtn.style.display = "none";

const toggleLangBtn = document.getElementById("btnToggleLang");
if (toggleLangBtn) toggleLangBtn.style.display = "none";


  const correctIdx = q.correct_arg ?? q.correct ?? 0;
  const correct = idx === correctIdx;

  const prefix = currentLanguage === "brz" ? "_brz" : "_arg";
  const explainBox = $("#qExplain");
  explainBox.style.display = "block";
  explainBox.innerHTML = correct
    ? "<div class='right'>‚úÖ Correcto</div>"
    : "<div class='wrong'>‚ùå Incorrecto</div>";
  explainBox.innerHTML +=
    "<p class='mt-1'>" + (q[`explain${prefix}`] || "") + "</p>";

  $$(".opt").forEach(btn => btn.style.pointerEvents = "none");

  setTimeout(() => {
    $("#qModal").classList.remove("active");
    $("#btnCloseQuestion").style.display = "inline-block";
    applyQuestionOutcome(correct, kind);
  }, 2500);
}




function applyQuestionOutcome(correct, kind) {
  if (gameEnded) return;

  const me = state.players[0];
  if (!me || !me.alive) {
    state.awaitingAnswer = false;
    endTurn();
    return;
  }

  let success = correct;


  // ==== ATAQUE ====
// ==== ATAQUE ====
if (kind === "attack") {
  const targetIdx = state.chosenTarget;
  if (targetIdx == null || !state.players[targetIdx] || !state.players[targetIdx].alive) {
    addLog(t("invalid_objective"));
    state.chosenTarget = null;
    state.awaitingAnswer = false;
    endTurn();
    return;
  }

  if (success) {
    // üéØ aplicar multiplicador de evento y da√±o extra (como bots)
    const basePts = SCORE_VALUES.ATTACK_SUCCESS;
    const pts = Math.round(basePts * (state.eventMultiplier || 1));
    state.score += pts;
    state.players[0].score = (state.players[0].score || 0) + pts;
    setTimeout(() => showPointsFloat("#player", pts), 300); // ‚≠ê delay visual

    const baseDamage = 2 + (state.eventExtraDamage || 0);
    const target = state.players[targetIdx];
    target.hp = clamp(target.hp - baseDamage, 0, MAX_HP);
    showDamageFloat(idFromIndex(targetIdx), baseDamage);

    addLog(t("attack_success", { 
      target: target.name, 
      damage: baseDamage, 
      pts 
    }));

    checkDeath(targetIdx);
    flashCell("#player", "violet");
    flashCell(idFromIndex(targetIdx), "red");
    launchProjectile("#player", idFromIndex(targetIdx));
    sfx.attack.play();
  } else {
    me.hp = clamp(me.hp - 1, 0, MAX_HP);
    showDamageFloat("#player", 1);

    addLog(t("attack_fail"));
    launchEffect("#player", "fail");
    flashCell("#player", "red");
    sfx.fail.play();
    checkDeath(0);
  }
}


  // ==== FORTIFICAR ====
if (kind === "fortify") {
  if (success) {
    const basePts = SCORE_VALUES.FORTIFY_SUCCESS;
    const pts = Math.round(basePts * (state.eventMultiplier || 1));
    const healAmount = 3;

    state.score += pts;
    state.players[0].score = (state.players[0].score || 0) + pts;
//showPointsFloat("#player", pts);

    me.hp = clamp(me.hp + healAmount, 0, MAX_HP);
    showDamageFloat("#player", healAmount, "heal");
    setTimeout(() => showPointsFloat("#player", pts), 300); // peque√±o delay lateral


    addLog(t("fortify_success", { heal: healAmount, pts }));
    flashCell("#player", "green");
    launchEffect("#player", "shield");
    sfx.fortify.play();
  } else {
    addLog(t("fortify_fail"));
    launchEffect("#player", "fail");
    sfx.fail.play();
  }
}



  // ==== ACTUALIZAR UI ====
  $("#score").textContent = state.score;

  // ‚ö†Ô∏è CR√çTICO: limpiar flags ANTES de pasar turno
  state.awaitingAnswer = false;
  state.chosenAction = null;
  state.chosenTarget = null;

  renderAll();

  // ==== PASAR TURNO ====
  if (!gameEnded) {
    endTurn();

    // üß† Si despu√©s de endTurn sigue siendo tu turno ‚Üí reanudar timer
    if (state.order[state.turnIdx] === 0 && !gameEnded) {
      startTurnTimer();
      togglePlayerControls(true);
    }
  }
}

    // ============================================
    // GESTI√ìN DE MUERTE
    // ============================================
function checkDeath(idx) {
  if (gameEnded) return;
  
  const p = state.players[idx];
  if (!p) return;
  
  if (p.hp <= 0 && p.alive) {
    p.alive = false;
    addLog(t("player_eliminated", { name: p.name }));

    sfx.death.play();

    // Remover del orden de turnos
    const currentId = state.order[state.turnIdx];
    state.order = state.order.filter(i => i !== idx);

    let newIdx = state.order.indexOf(currentId);
    if (newIdx === -1) {
      newIdx = state.turnIdx % state.order.length;
    }

    state.turnIdx = newIdx;

    // Game over si muere el jugador
    if (idx === 0) {
      return gameOver(false);
    }

    // Bonus por eliminar bot
    const killerIsPlayer = state.order[state.turnIdx] === 0;
    if (killerIsPlayer) {
      state.score += SCORE_VALUES.KILL_BONUS;
      state.players[0].score = (state.players[0].score || 0) + SCORE_VALUES.KILL_BONUS;
      $("#score").textContent = state.score;
      addLog(t("kill_bonus"));

      setTimeout(() => showPointsFloat("#player", SCORE_VALUES.KILL_BONUS), 800);
      sfx.event_double.play();
    } else {
      const killer = state.players[state.order[state.turnIdx]];
      if (killer && killer.type === "bot") {
        killer.score = (killer.score || 0) + SCORE_VALUES.KILL_BONUS;
        addLog(t("bot_kill_bonus", { 
          killer: killer.name, 
          bonus: SCORE_VALUES.KILL_BONUS, 
          victim: p.name 
        }));

        setTimeout(() => showPointsFloat(idFromIndex(state.order[state.turnIdx]), SCORE_VALUES.KILL_BONUS), 800);
        sfx.event_double.play();
      }
    }

    // Victoria si todos los bots murieron
    const vivosBots = state.players.slice(1).filter(x => x.alive).length;
    if (vivosBots === 0) {
      gameOver(true);
    }
  }
}
function idFromIndex(i) {
  switch (i) {
    case 0: return "#player";
    case 1: return "#p1";
    case 2: return "#p2";
    case 3: return "#p3";
    case 4: return "#p4";
    case 5: return "#p5";
    case 6: return "#p6";
    case 7: return "#p7";
    default: return null;
  }
}


    // Hace destellar el recuadro de un jugador
function flashCell(selector, color) {
  // Buscamos directamente la celda (ya no el padre)
  const cell = $(selector);
  if (!cell) return;

  const className = `flash-${color}`;
  cell.classList.add(className);

  // Removemos despu√©s del efecto
  setTimeout(() => cell.classList.remove(className), 1200);
}



    // ============================================
    // TURNOS Y BOTS
    // ============================================
function endTurn() {
  if (gameEnded) return;

  // Reset flags
  state.awaitingAnswer = false;
  state.chosenAction = null;
  state.chosenTarget = null;

  // Avanzar al siguiente turno
  state.turnIdx = (state.turnIdx + 1) % state.order.length;

  // Si vuelve al jugador humano => nueva ronda
if (state.turnIdx === 0) {
  state.round++;
  $("#round").textContent = state.round;
  applyRoundEvent();

  // üí´ Recompensa por sobrevivir
  state.players.forEach((p, idx) => {
    if (p.alive) {
      p.score = (p.score || 0) + 100;

      // üîπ Si es el jugador humano (idx = 0)
      if (idx === 0) {
        state.score += 100;
        $("#score").textContent = state.score;

        // üî∏ Texto flotante +100 sobre el jugador
        const text = document.createElement("div");
        text.className = "floating-points";
        text.textContent = "+100";
        const castle = document.querySelector("#player");
        castle.appendChild(text);
        setTimeout(() => text.remove(), 1200);
      }
    }
    /*
    if (p.alive && p.hp < MAX_HP) {
      p.hp = clamp(p.hp + 1, 0, MAX_HP);
      showDamageFloat(idFromIndex(idx), 1, "heal");
    }
      */
  });

  addLog(t("round_bonus"));
  renderAll();
}


  renderAll();
  highlightTurn();
  startTurnTimer();

  // Si el turno es de un bot => ejecutar IA
  const idx = state.order[state.turnIdx];
  const player = state.players[idx];

if (player && player.type === "bot" && player.alive) {
  const turnSnapshot = state.round + "-" + state.turnIdx;
// üïê Espera aleatoria antes de que el bot act√∫e (m√°s natural)
const delay = 1000 + Math.random() * 800; // entre 1.0 y 1.8 s aprox
setTimeout(() => {
  // üí° verificamos que sigue siendo su turno
  if (state.round + "-" + state.turnIdx === turnSnapshot) {
    botAct(idx);
  }
}, delay);

}

}

function botAct(idx) {
  if (gameEnded) return;
  if (state.order[state.turnIdx] !== idx) return;

  const bot = state.players[idx];
  if (!bot || !bot.alive) { endTurn(); return; }

  // ‚ë† Mostrar mensaje "pensando..." ANTES de actuar
  const msg = rnd(getThoughts()).replace("{name}", bot.name); // üîπ CAMBIADO AQU√ç
  botSay(idx, msg, 1200);

  // Tomamos un snapshot para evitar actuar si el turno cambi√≥
  const turnSnapshot = state.round + "-" + state.turnIdx;

  // ‚ë° Despu√©s del breve delay, ejecutar la IA normal
  const actionDelay = 1000 + Math.random() * 900;
  setTimeout(() => {
    if (gameEnded) return;
    if (state.round + "-" + state.turnIdx !== turnSnapshot) return;
  
    let action;

    if (bot.hp <= 2) {
      action = Math.random() < 0.7 ? "fortify" : "repair";
    } else if (bot.hp >= 5) {
      action = Math.random() < 0.8 ? "attack" : "fortify";
    } else {
      const r = Math.random();
      if (r < 0.5) action = "attack";
      else if (r < 0.8) action = "fortify";
      else action = "repair";
    }

    // ==== REPARAR ====
    if (action === "repair") {
      bot.hp = clamp(bot.hp + 1, 0, MAX_HP);
      showDamageFloat(idFromIndex(idx), 1, "heal");
     addLog(t("bot_heal", { name: bot.name }));
      renderAll();
      flashCell(idFromIndex(idx), "green");
      launchEffect(idFromIndex(idx), "heal");
      sfx.heal.play();
      return endTurn();
    }

    // ==== FORTIFICAR ====
if (action === "fortify") {
  const success = rollBot(bot, "fortify");
  if (success) {
    const healAmount = 3; // igual que jugador
    bot.hp = clamp(bot.hp + healAmount, 0, MAX_HP);
    showDamageFloat(idFromIndex(idx), healAmount, "heal");

    const basePts = SCORE_VALUES.FORTIFY_SUCCESS;
    const pts = Math.round(basePts * (state.eventMultiplier || 1));
    bot.score = (bot.score || 0) + pts;

    // üí´ Mostrar los puntos despu√©s de 300ms (igual que el jugador)
    setTimeout(() => showPointsFloat(idFromIndex(idx), pts), 300);

    addLog(t("bot_fortify_success", { name: bot.name, heal: healAmount, pts }));
    launchEffect(idFromIndex(idx), "shield");
    flashCell(idFromIndex(idx), "green");
    sfx.fortify.play();
  } else {
    addLog(t("bot_fortify_fail", { name: bot.name }));
    launchEffect(idFromIndex(idx), "fail");
    sfx.fail.play();
  }
  renderAll();
  return endTurn();
}


    // ==== ATAQUE ====
    if (action === "attack") {
      const targets = state.players
        .map((p, i) => ({ i, p }))
        .filter(x => x.i !== idx && x.p && x.p.alive);

      if (targets.length === 0) return endTurn();

      let target;
      const chanceAttackPlayer = 0.23;
      if (Math.random() < chanceAttackPlayer && state.players[0].alive) {
        target = { i: 0, p: state.players[0] };
      } else {
        const botsOnly = targets.filter(t => t.i !== 0);
        target = botsOnly.length > 0 ? rnd(botsOnly) : rnd(targets);
      }

      const success = rollBot(bot, "attack");

if (success) {
  const baseDamage = 2 + (state.eventExtraDamage || 0);
  target.p.hp = clamp(target.p.hp - baseDamage, 0, MAX_HP);
showDamageFloat(idFromIndex(target.i), baseDamage);

const basePts = SCORE_VALUES.ATTACK_SUCCESS;
const pts = Math.round(basePts * (state.eventMultiplier || 1));
bot.score = (bot.score || 0) + pts;
setTimeout(() => showPointsFloat(idFromIndex(idx), pts), 300);


  addLog(t("bot_attack_success", { 
  attacker: bot.name, 
  target: target.p.name, 
  damage: baseDamage, 
  pts 
}));
  checkDeath(target.i);
  flashCell(idFromIndex(idx), "violet");
  flashCell(idFromIndex(target.i), "red");
  sfx.attack.play();
  launchProjectile(idFromIndex(idx), idFromIndex(target.i));
} else {
  const penalty = state.eventAccuracyPenalty ? 1 + state.eventAccuracyPenalty : 1;
  const damage = Math.round(1 * penalty);
  bot.hp = clamp(bot.hp - damage, 0, MAX_HP);
  showDamageFloat(idFromIndex(idx), damage);

  
addLog(t("bot_attack_fail", { name: bot.name, damage }));
  launchEffect(idFromIndex(target.i), "fail");
  sfx.fail.play();
  checkDeath(idx);
}


      renderAll();
      return endTurn();
    }
  }, actionDelay);
}

    function rollBot(bot, kind) {
    let acc = bot.acc;

    // Ajustes por personalidad
    const topic = rnd(["Independencia", "Uni√≥n", "Complemento", "Condicional", "Bayes", "Prob. total"]);
    
    if (bot.name === "Frecuent√≠n" && topic === "Independencia") {
        acc -= 0.1;
    }
    if (bot.name === "Bayesito" && (topic === "Bayes" || topic === "Condicional")) {
        acc += 0.08;
    }

    acc = clamp(acc, 0.1, 0.95);
    return Math.random() < acc;
    }

// =====================================================
// ANIMACI√ìN DE PROYECTIL R√ÅPIDO (VIOLETA)
// =====================================================
function launchProjectile(fromSelector, toSelector) {
  const fromEl = document.querySelector(fromSelector);
  const toEl = document.querySelector(toSelector);
  if (!fromEl || !toEl) return;

  const fromRect = fromEl.getBoundingClientRect();
  const toRect = toEl.getBoundingClientRect();

  // Crear proyectil
  const projectile = document.createElement("div");
  projectile.className = "projectile";
  document.body.appendChild(projectile);

  // Posici√≥n inicial
  const startX = fromRect.left + fromRect.width / 2;
  const startY = fromRect.top + fromRect.height / 2;
  const endX = toRect.left + toRect.width / 2;
  const endY = toRect.top + toRect.height / 2;

  projectile.style.left = `${startX}px`;
  projectile.style.top = `${startY}px`;

  // Forzar reflow para que la transici√≥n se aplique
  void projectile.offsetWidth;

  const dx = endX - startX;
  const dy = endY - startY;

  // Movimiento r√°pido (m√°s corto)
  projectile.style.transitionDuration = "0.35s";
  projectile.style.transform = `translate(${dx}px, ${dy}px) scale(1.3)`;

  // Desvanecer y eliminar despu√©s del impacto
  setTimeout(() => {
    projectile.style.opacity = "0";
    setTimeout(() => projectile.remove(), 200);
  }, 350);
}

// =====================================================
// EFECTOS DE CURACI√ìN / FORTIFICACI√ìN / FALLO
// =====================================================
function launchEffect(selector, type) {
  const targetEl = document.querySelector(selector);
  if (!targetEl) return;

  const rect = targetEl.getBoundingClientRect();
  const effect = document.createElement("div");
  effect.className = `effect-${type}`;

  document.body.appendChild(effect);
  effect.style.left = `${rect.left + rect.width / 2}px`;
  effect.style.top = `${rect.top + rect.height / 2}px`;

  setTimeout(() => effect.remove(), 1000);
}

// =====================================================
// EFECTO DE VIDA (üíî / üíö) ‚Äî con desplazamiento opcional
// =====================================================
function showDamageFloat(selector, amount, type = "damage", offsetY = 0) {
  const target = document.querySelector(selector);
  if (!target) return;

  const rect = target.getBoundingClientRect();
  const float = document.createElement("div");
  float.className = `damage-float ${type}`;
  float.innerHTML = type === "damage" ? `üíî -${amount}` : `üíö +${amount}`;

  document.body.appendChild(float);
  float.style.left = `${rect.left + rect.width / 2}px`;
  float.style.top = `${rect.top + rect.height / 2 - 10 + offsetY}px`;

  setTimeout(() => float.remove(), 1200);
}

// =====================================================
// EFECTO DE PUNTOS (‚≠ê) ‚Äî con desplazamiento opcional
// =====================================================
function showPointsFloat(selector, amount, offsetY = 0) {
  const target = document.querySelector(selector);
  if (!target) return;

  const rect = target.getBoundingClientRect();
  const float = document.createElement("div");
  float.className = "points-float";
  float.innerHTML = `‚≠ê +${amount}`;

  document.body.appendChild(float);
  float.style.left = `${rect.left + rect.width / 2}px`;
  float.style.top = `${rect.top + rect.height / 2 - 10 + offsetY}px`;

  setTimeout(() => float.remove(), 1200);
}



    // ============================================
    // FIN DE JUEGO
    // ============================================
function gameOver(win) {
  if (gameEnded) return;
  
  gameEnded = true;
  clearInterval(state.interval);

  const vivos = state.players.filter(p => p && p.alive);
  $("#endTitle").textContent = win ? t("game_over_win") : t("game_over_lose");
  
  const aliveNames = vivos.map(v => v.name).join(", ") || t("stats_none");
  $("#endStats").innerHTML = t("stats_rounds", {
    rounds: state.round,
    score: state.score,
    alive: aliveNames
  });

  // Actualizar mejor puntaje
  const best = Number(localStorage.getItem("bp_best") || 0);
  if (state.score > best) {
    localStorage.setItem("bp_best", String(state.score));
    addLog(t("new_record", { score: state.score }));
  }
  $("#best").textContent = Math.max(best, state.score);

  music.pause();
  music.currentTime = 0;

  if (win) {
    sfx.victory.play();
  } else {
    sfx.gameover.play();
  }

  setTimeout(() => {
    $("#endOverlay").classList.add("active");
  }, 500);
}
    // ============================================
    // UI: INICIO Y REINICIO
    // ============================================
// ============================================
// UI: INICIO Y REINICIO
// ============================================

// ‚úÖ versi√≥n corregida con carga de preguntas antes de iniciar
$("#btnStart").onclick = async () => {
  const name = ($("#playerNameInput").value || "Jugador").trim().slice(0, 20);
  await loadGameMessages(); // üîπ Asegurar que los mensajes est√©n cargados
  await loadQuestions();
  const mode = $("#modeFull").checked ? "full" : "normal";
  $("#startOverlay").classList.remove("active");
  newGame(name, mode);
  const grid = document.getElementById("grid");
  grid.classList.remove("normal", "full");
  grid.classList.add(mode === "full" ? "full" : "normal");
};

$("#btnRestart").onclick = () => {
  location.reload();
};

$("#btnPlayAgain").onclick = () => {
  $("#endOverlay").classList.remove("active");
  const name = state.players[0].name;
  const mode = (state.players.length >= 8) ? "full" : "normal";

  // üéµ Reiniciar y reproducir m√∫sica desde el inicio
  music.currentTime = 0;
  music.play();
  $("#btnPlayMusic").textContent = "‚è∏Ô∏è";

  newGame(name, mode);
  const grid = document.getElementById("grid");
  grid.classList.remove("normal", "full");
  grid.classList.add(mode === "full" ? "full" : "normal");
};



$("#btnHelp").onclick = () => {
  alert(t("help_title") + "\n\n" + t("help_text"));
};

// ===========================
// AUDIO SYSTEM
// ===========================
const music = new Audio("../src/audio/gameBattle/game.mp3");
music.loop = true;
music.volume = 0.45;

const sfx = {
  heal: new Audio("../src/audio/gameBattle/heal.mp3"),
  fortify: new Audio("../src/audio/gameBattle/forti.mp3"),
  attack: new Audio("../src/audio/gameBattle/attack.mp3"),
  fail: new Audio("../src/audio/gameBattle/miss.mp3"),
  victory: new Audio("../src/audio/gameBattle/victory.mp3"),
  gameover: new Audio("../src/audio/gameBattle/gameover.mp3"),
  death: new Audio("../src/audio/gameBattle/npcdeath.mp3"),
  event_double: new Audio("../src/audio/gameBattle/event_double.mp3"),
  event_heal: new Audio("../src/audio/gameBattle/event_heal.mp3"),
  event_fury: new Audio("../src/audio/gameBattle/event_fury.mp3"),
  event_none: new Audio("../src/audio/gameBattle/event_none.mp3")
};

// üîä Aplicar volumen inicial del slider a todos los sonidos
// üîä Aplicar volumen inicial del slider a todos los sonidos
const initialVol = parseFloat($("#volumeControl").value);
music.volume = initialVol;
Object.values(sfx).forEach(a => (a.volume = initialVol));

// üîπ Actualiza el icono inicial seg√∫n el volumen
updateMusicButton();

function updateMusicButton() {
  if (music.paused) {
    $("#btnPlayMusic").textContent = "‚ñ∂Ô∏è";
  } else if (music.volume === 0) {
    $("#btnPlayMusic").textContent = "üîá";
  } else {
    $("#btnPlayMusic").textContent = "üîä";
  }
}

// üéµ Bot√≥n Play / Pause / Mute visual
$("#btnPlayMusic").onclick = () => {
  if (music.paused) {
    music.play();
  } else {
    music.pause();
  }
  updateMusicButton();
};

// üéöÔ∏è Control de volumen con detecci√≥n de mute
$("#volumeControl").oninput = e => {
  const v = parseFloat(e.target.value);
  music.volume = v;
  Object.values(sfx).forEach(a => (a.volume = v));
  updateMusicButton();
};

// üß† Si el volumen arranca en 0, mostrar mute
if (initialVol === 0) updateMusicButton();



    // ============================================
    // INICIALIZACI√ìN
    // ============================================
    // Render inicial vac√≠o al cargar la p√°gina
    if ($("#player")) {
["#player", "#p1", "#p2", "#p3"].forEach(sel => {
  const box = $(sel);
  if (box) {
    box.innerHTML = `
      <div class="name muted">‚Äî</div>
      <div class="lifes">ü§çü§çü§çü§çü§ç</div>
    `;
  }
});

    }


// ===============================
// üåé CAMBIO DE IDIOMA GLOBAL UI (bidireccional)
// ===============================
async function loadGameLanguage(lang = "arg") {
  try {
    const response = await fetch(`../src/json/game_${lang}.json`);
    if (!response.ok) throw new Error(`Archivo game_${lang}.json no encontrado`);
    const data = await response.json();
    const ui = data.ui || {};

    document.querySelectorAll("[data-key]").forEach(el => {
      const key = el.getAttribute("data-key");
      if (ui[key]) {
        if (el.tagName === "INPUT" && el.placeholder !== undefined) {
          el.placeholder = ui[key];
        } else {
          el.textContent = ui[key];
        }
      }
    });

    const label = document.getElementById("langLabel");
    if (label) label.textContent = lang === "arg" ? "üá¶üá∑ ARG" : "üáßüá∑ BR";

    localStorage.setItem("uiLang", lang);
    
    // üîπ SINCRONIZAR IDIOMA DE MENSAJES
    syncGameLanguage(lang);
    
    // üî• ACTUALIZAR TODO EL JUEGO SI EST√Å ACTIVO
    if (state && !gameEnded) {
      refreshGameLanguage();
    }
    
  } catch (err) {
    console.error("‚ùå Error cargando idioma:", err);
  }
}


// ============================================
// üîÑ REFRESCAR TODO EL IDIOMA DEL JUEGO
// ============================================
function refreshGameLanguage() {
  if (!state) return;

  // üîπ Actualizar evento actual si existe
  if (state.currentEvent) {
    const suffix = currentGameLang === "brz" ? "_brz" : "_arg";
    const event = state.currentEvent;
    $("#eventName").textContent = event[`name${suffix}`];
    $("#eventDesc").textContent = event[`desc${suffix}`];
  } else {
    // Si no hay evento, mostrar "Silencio de la Bandera"
    const suffix = currentGameLang === "brz" ? "_brz" : "_arg";
    $("#eventName").textContent = ROUND_EVENTS[3][`name${suffix}`];
    $("#eventDesc").textContent = ROUND_EVENTS[3][`desc${suffix}`];
  }

  // üîπ Re-renderizar todos los jugadores (actualiza "Bot"/"Jugador")
  renderAll();

  // üîπ Actualizar mensajes del log (traducir los √∫ltimos mensajes)
  refreshLogMessages();

  // üîπ Si hay una pregunta abierta, actualizarla
  if (state.awaitingAnswer && currentQuestion) {
    renderQuestion(currentQuestion, currentGameLang);
  }

  // üîπ Actualizar game over si est√° activo
  if (gameEnded) {
    refreshGameOverScreen();
  }
}

// ============================================
// üîÑ REFRESCAR MENSAJES DEL LOG
// ============================================
function refreshLogMessages() {
  // Guardamos los mensajes actuales con sus datos
  const messages = Array.from(logBox.children).map(p => {
    const html = p.innerHTML;
    return {
      html,
      // Intentamos detectar el tipo de mensaje por su contenido
      type: detectMessageType(html)
    };
  });

  // Limpiamos el log
  logBox.innerHTML = "";

  // Re-agregamos los mensajes traducidos (invertidos porque usamos prepend)
  messages.reverse().forEach(msg => {
    const translatedHTML = translateLogMessage(msg.html, msg.type);
    const p = document.createElement("p");
    p.innerHTML = translatedHTML;
    logBox.appendChild(p);
  });
}

function detectMessageType(html) {
  if (html.includes("üéÆ") && html.includes("partida")) return "game_started";
  if (html.includes("‚è±Ô∏è") && html.includes("tiempo")) return "time_out";
  if (html.includes("‚öîÔ∏è") && html.includes("Eleg√≠")) return "choose_target";
  if (html.includes("‚ö†Ô∏è")) return "invalid_target";
  if (html.includes("üíä") && html.includes("cura")) return "heal";
  if (html.includes("‚öîÔ∏è") && html.includes("Atac√°s")) return "attack_success";
  if (html.includes("‚öîÔ∏è") && html.includes("Fallaste")) return "attack_fail";
  if (html.includes("üõ°Ô∏è") && html.includes("fortific√°s")) return "fortify_success";
  if (html.includes("üõ°Ô∏è") && html.includes("Fallaste")) return "fortify_fail";
  if (html.includes("üí•")) return "eliminated";
  if (html.includes("üéâ") && html.includes("200")) return "kill_bonus";
  if (html.includes("üíÄ") && html.includes("gana")) return "bot_kill";
  if (html.includes("üí´") && html.includes("100")) return "round_bonus";
  if (html.includes("üéä")) return "new_record";
  if (html.includes("üåÄ")) return "event";
  if (html.includes("‚ùå") && html.includes("Cerraste")) return "question_closed";
  
  return "unknown";
}

function translateLogMessage(html, type) {
  // Extraer nombres y n√∫meros del mensaje original
  const nameMatch = html.match(/<b>([^<]+)<\/b>/g);
  const numberMatch = html.match(/\d+/g);

  switch (type) {
    case "game_started":
      return t("game_started");
    
    case "time_out":
      if (html.includes("perd√©s")) {
        return t("time_out_player");
      } else if (nameMatch) {
        const name = nameMatch[0].replace(/<\/?b>/g, "");
        return t("time_out_bot", { name });
      }
      break;
    
    case "choose_target":
      return t("choose_target");
    
    case "invalid_target":
      return t("invalid_target");
    
    case "heal":
      if (nameMatch) {
        const name = nameMatch[0].replace(/<\/?b>/g, "");
        // Detectar si es bot o jugador por el contexto
        if (html.includes("se cura") && !html.includes("Tu ")) {
          return t("bot_heal", { name });
        } else {
          return t("heal_self", { name });
        }
      }
      break;
    
    case "attack_success":
      if (nameMatch && numberMatch) {
        const target = nameMatch[0].replace(/<\/?b>/g, "");
        const damage = numberMatch[0];
        const pts = numberMatch[1] || 0;
        return t("attack_success", { target, damage, pts });
      }
      break;
    
    case "attack_fail":
      return t("attack_fail");
    
    case "fortify_success":
      if (numberMatch) {
        const heal = numberMatch[0];
        const pts = numberMatch[1] || 0;
        return t("fortify_success", { heal, pts });
      }
      break;
    
    case "fortify_fail":
      return t("fortify_fail");
    
    case "eliminated":
      if (nameMatch) {
        const name = nameMatch[0].replace(/<\/?b>/g, "");
        return t("player_eliminated", { name });
      }
      break;
    
    case "kill_bonus":
      return t("kill_bonus");
    
    case "bot_kill":
      if (nameMatch && numberMatch) {
        const killer = nameMatch[0].replace(/<\/?b>/g, "");
        const victim = nameMatch[1] ? nameMatch[1].replace(/<\/?b>/g, "") : "";
        const bonus = numberMatch[0];
        return t("bot_kill_bonus", { killer, victim, bonus });
      }
      break;
    
    case "round_bonus":
      return t("round_bonus");
    
    case "new_record":
      if (numberMatch) {
        return t("new_record", { score: numberMatch[0] });
      }
      break;
    
    case "event":
      // Los eventos ya se traducen din√°micamente
      return html;
    
    case "question_closed":
      return t("question_closed");
    
    default:
      return html; // Mantener mensaje original si no se puede traducir
  }
  
  return html;
}



// ============================================
// üîÑ REFRESCAR PANTALLA DE GAME OVER
// ============================================
function refreshGameOverScreen() {
  if (!gameEnded) return;

  const vivos = state.players.filter(p => p && p.alive);
  const win = vivos.some(p => p.type === "human");
  
  $("#endTitle").textContent = win ? t("game_over_win") : t("game_over_lose");
  
  const aliveNames = vivos.map(v => v.name).join(", ") || t("stats_none");
  $("#endStats").innerHTML = t("stats_rounds", {
    rounds: state.round,
    score: state.score,
    alive: aliveNames
  });
}
// üéØ Alternar idioma (ARG ‚Üî BRZ)
const langBtn = document.getElementById("langToggle");
if (langBtn) {
  langBtn.addEventListener("click", async () => {
    const current = localStorage.getItem("uiLang") || "arg";
    const next = current === "arg" ? "brz" : "arg";
    await loadGameLanguage(next);
  });
}

document.addEventListener("DOMContentLoaded", async () => {
  await loadGameMessages(); // üîπ Cargar traducciones primero
  const saved = localStorage.getItem("uiLang") || "arg";
  await loadGameLanguage(saved);
  syncGameLanguage(saved); // üîπ Sincronizar idioma inicial
});


    </script>

    <script src="../src/js/flag-back-scroll.js"></script>
</body> 

</html>